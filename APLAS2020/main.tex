% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads, anon]{llncs}
\usepackage[numbers]{natbib}


\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{common/common}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{color,soul}




%\definecolor{lightYellow}{rgb}{1,1,0.8}
\definecolor{lightYellow}{rgb}{1,1,0.8}



\lstdefinestyle{custom_lang}{
%   language = scala,
	escapeinside={*}{*},
  	showstringspaces=false,
  	basicstyle={\ttfamily},
  	keywordstyle=\color{blue},
  	keywords = [1]{def},
  	otherkeywords = {<:, >:, =, ->, =>},
  	morekeywords = [2]{<:, >:, =, ->, =>, this},
%	
	keywordstyle = [1]{\tt \bfseries \color{red}},
	keywordstyle = [2]{\tt \bfseries \color{blue}},
%	morekeywords = [2]{class, interface, module, val, type, def, object, var},
%	morekeywords = [3]{match, with, this},
%	morekeywords = [4]{<:, >:, =, ->, =>},
	frame=single
}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Syntactically Restricting Bounded Polymorphism for Decidable Subtyping}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Anonymous Author(s)}
%
\authorrunning{Anonymous}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
%\institute{Princeton University, Princeton NJ 08544, USA \and
%Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
%\email{lncs@springer.com}\\
%\url{http://www.springer.com/gp/computer-science/lncs} \and
%ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
%\email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Subtyping of Bounded Polymorphism has long been known
to be undecidable when coupled with contra-variance. While decidable forms of bounded polymorphism exist, they all either sacrifice useful properties such as contra-variance 
(Kernel F$_{<:}$), or 
useful metatheoretic properties (F$_{<:}^\top$).
In this paper we show how by syntactically separating contra-variance from 
the recursive aspects of subtyping in System F$_{<:}$, decidable subtyping can be ensured while also allowing for both contra-variant subtyping
of certain quantified types, and many of System F$_{<:}$'s desirable metatheoretic properties. We then show that this approach can be applied to the related polymorphism present in D$_{<:}$, a minimal calculus that models core features of the Scala type system.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}
\label{s:intro}

Bounded quantification (or bounded polymorphism) is a powerful and widely used language construct that introduces a form of 
abstraction for types. Where functions provide an abstraction of behavior for values, bounded quantification 
provides an abstraction of behavior for types. A motivating example is an addition function for numbers. Below we
provide such an example using no particular language syntax (although it resembles Scala).
\begin{lstlisting}[mathescape, style=custom_lang]
def plus [A <: Real] : A -> A -> A
\end{lstlisting}
The type \verb|A| is unimportant except in that A is some subtype of \verb|Real| (the upper bound on \verb|A|). Ideally we would like to 
\verb|plus| to be defined abstractly for any value that could be considered a \verb|Real|, and not have to write 
a separate function for \verb|Integer|, \verb|Natural|, and \verb|Real|. \verb|plus| is  quantified over type \verb|A| which is 
bounded by \verb|Real|.

Bounded quantification has been adopted by many different languages, and is not exclusive to any specific paradigm.
Java Generics provide a form of bounded quantification for both method and class definitions.
Scala includes generics similar to that of Java (only more flexible), but adds abstract type members on top, further complicating matters.

Unfortunately, several forms of bounded quantification have been shown to exhibit undecidable subtyping.
To the surprise of many at the time, Pierce \cite{Pierce:1992:BQU:143165.143228} demonstrated that subtyping in \Fsub, a typed $\lambda$-calculus with subtyping and bounded quantification, 
was undecidable by a reduction to the halting problem.
More recently , and to perhaps less surprise, subtyping of Java Generics was also shown to be undecidable.
Hu and Lhot\'{a}k \cite{10.1145/3371077} showed subtyping of D$_{<:}$, a minimal calculus, capturing parts of the Scala type system, was undecidable by a reduction to an undecidable fragment of \Fsub.
Mackay et al. \cite{10.1145/3371134} developed two decidable variants on Wyvern, a programming language closely related to Scala. 
Mackay et al. focused on recursive types in Scala, but touched on bounded quantification.

If subtyping in languages with relatively wide usage is undecidable, then one might ask the question: how important is decidable subtyping in practice?
Unfortunately, undecidability means that type checking of certain programs will not terminate, and will eventually crash without any error message indicating the problem.
In writing a compiler, one fix to this problem might be to enforce a maximal depth on proof search, or to simply timeout during type checking. These are unsatisfying 
solutions, as not only might they exclude some false negatives, but they also won't be able to provide the programmer much guidance on debugging their program.
Thus, while presumably rare, the potential problems are severe.

In this paper we show how simple syntactic restrictions can allow for decidable forms of bounded quantification that are easy to type check, 
allow for informative error messages, all while retaining many of the useful properties of typing in \Fsub: subtype transitivity, type safety, and minimal typing.

\section{The Undecidability of Bounded Quantification in \Fsub}
\label{s:background}

Bounded polymorphism was formalized in \Fsub by Cardelli \cite{cardelli1991}, and shown to be undecidable by Pierce \cite{Pierce:1992:BQU:143165.143228}.
\Fsub introduces bounded quantification to the simply typed $\lambda$-calculus by way of a universally quantified syntactic form with the
following typing rule.
\begin{mathpar}
\infer
	{
	\Gamma, (\alpha \leqslant \tau_1) \vdash t\ :\ \tau_2
	}
	{
	\Gamma \vdash \Lambda (\alpha \leqslant \tau_1).t\ :\ \forall (\alpha \leqslant \tau_1).\tau_2
	}
\end{mathpar}
That is, term $t$, with type $\tau_2$, is quantified over some type, represented by $\alpha$, whose upper bound is $\tau_1$.
The undecidability of subtyping in \Fsub was demonstrated by a reduction of subtyping to the halting problem.
The reduction to the halting problem relies on the contra-variance in the subtyping rule for universally quantified types given below.
\begin{mathpar}
\infer
	{
	\Gamma \vdash \tau_2\ <:\ \tau_1 \\
	\Gamma, (\alpha \leqslant \tau_2) \vdash \tau_1'\ <:\ \tau_2'
	}
	{
	\Gamma \vdash \forall (\alpha \leqslant \tau_1).\tau_1'\ :\ \forall (\alpha \leqslant \tau_2).\tau_2'
	}
	\quad(\textsc{S-All})
\end{mathpar}
As can be seen above, subtyping of universally quantified types in \Fsub allows for contra-variance on the bound of the quantified type.
Kernel F$_{<:}$, a variant of \Fsub, has been shown to be decidable in its subtyping \cite{Pierce:2002:TPL:509043}. Kernel F$_{<:}$ removes the contra-variance of the \textsc{S-All} rule above, 
and instead enforces invariance on the bound.
\begin{mathpar}
\infer
	{
	\Gamma, (\alpha \leqslant \tau) \vdash \tau_1\ <:\ \tau_2
	}
	{
	\Gamma \vdash \forall (\alpha \leqslant \tau).\tau_1\ :\ \forall (\alpha \leqslant \tau).\tau_2
	}
	\quad(\textsc{S-All-Kernel})
\end{mathpar}
While decidable, \textsc{S-All-Kernel} is unsatisfying as it excludes desirable behavior. 
Ideally, we would like the \verb|plus| function, from Section \ref{s:intro}, to be substitutable for some other function defined for the more general type \verb|Number|:
\begin{lstlisting}[mathescape, style=custom_lang]
def add [A <: Number] : A -> A -> A
\end{lstlisting}
Castagna and Pierce \cite{10.1145/174675.177844} attempted to introduce such variance in a safe way by proposing F$^\top_{<:}$ 
with the following subtyping rule for universally quantified types.
\begin{mathpar}
\infer
	{
	\Gamma \vdash \tau_2\ <:\ \tau_1 \\
	\Gamma, (\alpha \leqslant \top) \vdash \tau_1'\ <:\ \tau_2'
	}
	{
	\Gamma \vdash \forall (\alpha \leqslant \tau_1).\tau_1'\ :\ \forall (\alpha \leqslant \tau_2).\tau_2'
	}
	\quad(\textsc{S-All$^\top$})
\end{mathpar}
Unfortunately, while decidable, F$_{<:}^\top$ sacrifices minimal typing. 
That is, it is possible to write a term in F$_{<:}^\top$ that can be typed 
with two different, and unrelated types \cite{10.1145/199448.199539}. A lack of minimal 
typing means that the typing algorithm for F$_{<:}^\top$ is not complete.

\section{Separating Recursion and Contra-variance in \Fsub}
In this section we present a variant of \Fsub that introduces a syntactic restriction on bounded quantification to achieve decidable subtyping.
We start by introducing the type syntax of \Fsub in Figure \ref{f:fsub :syntax}. Since we are only concerned with subtyping, and not typing, we only present 
the type syntax. The term syntax and typing rules can be found in Appendix \ref{app:fsub}. Further, throughout the rest of this paper, we refer 
to several different definitions of subtyping and typing. To distinguish between these differences, we annotate the the judgment.
We have already mentioned three different subtyping definitions, and differentiate them here
\begin{itemize}
\item
Subtyping for \Fsub as defined by Cardelli et al. \cite{cardelli1991} is indicated as $\Gamma \vdash \tau_1\ <:\ \tau_2$.
\item
Subtyping for Kernel F$_{<:}$ is indicated as $\Gamma \vdash \tau_1\ <:^K\ \tau_2$.
Subtyping for F$_{<:}^\top$ is indicated as $\Gamma \vdash \tau_1\ <:^\top\ \tau_2$.
\end{itemize}

A type in \Fsub is either the top type ($\top$), a bounded type variable ($\alpha$), an arrow type ($\tau \rightarrow \tau$), or a universally quantified type ($\forall(\alpha\leqslant\tau).\tau$).

\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
%\begin{array}{lcr}
\begin{syntax}
\syntaxElement{\tau}{\Fsub Type}
	{\top}{top}
	{\alpha}{variable}
	{\tau \rightarrow \tau}{arrow}
	{\forall (\alpha \leqslant \tau).\tau}{all}
\endSyntaxElement
\end{syntax}
\]
\caption{\Fsub Type Syntax}
\label{f:fsub :syntax}
\end{minipage}
\end{figure}

In Figure \ref{f:fsub:subtyping} we define the subtyping of F$_{<:}^N$, a normal form of subtyping in \Fsub, defined by Pierce \cite{Pierce:1992:BQU:143165.143228}. Subtyping is bounded above by $\top$ (\textsc{S$^N$-Top}) and explicitly reflexive in the case of type variables (\textsc{S$^N$-Rfl}).
A type supertypes a type variable if it supertypes its upper bound (\textsc{S$^N$-Var}).
Subtyping of arrow types is contra-variant with respect to its argument type, and covariant with respect to its return type (\textsc{S$^N$-Arr}).
Finally, subtyping of universally quantified types is contra-variant with respect to the type bounds, and covariant with respect to the type bodies.
\begin{figure}[t]
\begin{mathpar}
\infer
	{}
	{\Gamma \vdash \tau\ <:^N\ \top}
	\quad (\textsc{S$^N$-Top})
	\and
\infer
	{}
	{\Gamma \vdash \alpha\ <:^N\ \alpha}
	\quad (\textsc{S$^N$-Rfl})
	\and
\infer
	{
	(\alpha\ \leqslant\ \tau)\ \in\ \Gamma \\
	\Gamma \vdash \tau'\ <:^N\ \tau
	}
	{\Gamma \vdash \alpha\ <:^N\ \tau}
	\quad (\textsc{S$^N$-Var})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^N\ \tau_1 \\
	\Gamma  \vdash \tau_1'\ <:^N\ \tau_2'
	}
	{\Gamma \vdash \tau_1 \rightarrow \tau_1'\ <:^N\ \tau_2 \rightarrow \tau_2'}
	\quad (\textsc{S$^N$-Arr})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^N\ \tau_1 \\
	\Gamma, (\alpha \leqslant \tau_2) \vdash \tau_1'\ <:^N\ \tau_2'
	}
	{\Gamma \vdash \forall (\alpha\leqslant\tau_1).\tau_1'\ <:^N\ \forall(\alpha \leqslant \tau_2).\tau_2'}
	\quad (\textsc{S$^N$-All})
\end{mathpar}
\caption{\Fsub Subtyping}
\label{f:fsub:subtyping}
\end{figure}

Achieving a decidable variant of \Fsub follows a simple idea: we restrict contra-variance of type bounds to only types that do not themselves contain bounded quantification.
In Figure \ref{f:restricted:syntax}  we introduce a separated variant for the syntax of \Fsub called F$_{<:}^R$. 
\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcr}
\begin{syntax}
\syntaxElement{\tau}{F$_{<:}^R$ Type}
	{\top}{top}
	{\alpha}{variable}
	{\gamma}{restricted variable}
	{\tau \rightarrow \tau}{arrow}
	{\forall (\gamma \leqslant \rho).\tau}{restricted all}
	{\forall (\upsilon \leqslant \tau).\tau}{all}
\endSyntaxElement 
\end{syntax}
&

&
\begin{syntax}
\syntaxElement{\alpha}{Type Variable}
	{\upsilon}{unrestricted}
	{\gamma}{restricted}
\endSyntaxElement\\
\syntaxElement{\rho}{Restricted Type}
	{\top}{top}
	{\gamma}{variable}
	{\rho \rightarrow \rho}{arrow}
\endSyntaxElement
\end{syntax}
\end{array}
\]
\caption{F$_{<:}^R$ Type Syntax}
\label{f:restricted:syntax}
\end{minipage}
\end{figure}
In F$_{<:}^R$, types containing no bounded quantification are identified by $\gamma$. Their only difference from more general types is a lack of bounded quantification.
A restricted type, $\gamma$, is either $\top$, a restricted type variable $\rho$, or an arrow type.
We now define a restricted subtyping relation using the rule set in Figure \ref{f:sep:subtyping} 
%(Note: we omit rules for subtyping of $\top$, reflexivity, type variables, and arrow types as they are unchanged from Figure \ref{f:fsub:subtyping}).
\begin{figure}[t]
\begin{mathpar}
\infer
	{}
	{\Gamma \vdash \tau\ <:^R\ \top}
	\quad (\textsc{S$^R$-Top})
	\and
\infer
	{}
	{\Gamma \vdash \alpha\ <:^R\ \alpha}
	\quad (\textsc{S$^R$-Rfl})
	\and
\infer
	{
	(\alpha\ \leqslant\ \tau')\ \in\ \Gamma \\
	\Gamma \vdash \tau'\ <:^R \tau
	}
	{\Gamma \vdash \alpha\ <:^R\ \tau}
	\quad (\textsc{S$^R$-Var})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^R\ \tau_1 \\
	\Gamma  \vdash \tau_1'\ <^R:\ \tau_2'
	}
	{\Gamma \vdash \tau_1 \rightarrow \tau_1'\ <:^R\ \tau_2 \rightarrow \tau_2'}
	\quad (\textsc{S$^R$-Arr})
	\and
\infer
	{
	\Gamma, (\alpha \leqslant \tau)  \vdash \tau_1\ <:^R\ \tau_2
	}
	{\Gamma \vdash \forall(\alpha \leqslant \tau).\tau_1\ <:^R\ \forall(\alpha \leqslant \tau).\tau_2}
	\quad (\textsc{S$^R$-All-Kernel})
	\and
\infer
	{
	\Gamma \vdash \rho_2\ <:^R\ \rho_1 \\
	\Gamma, (\gamma \leqslant \rho_2) \vdash \tau_1\ <:^R\ \tau_2
	}
	{\Gamma \vdash \forall (\gamma \leqslant\rho_1).\tau_1\ <:^R\ \forall(\gamma \leqslant \rho_2).\tau_2}
	\quad (\textsc{S$^R$-All})
\end{mathpar}
\caption{F$_{<:}^R$ Subtyping}
\label{f:sep:subtyping}
\end{figure}

The subtyping of F$_{<:}^R$ defined in Figure \ref{f:sep:subtyping} replaces the \textsc{S$^N$-All} rule with two rules: \textsc{S$^R$-All-Kernel} and \textsc{S$^R$-All}. 
\textsc{S$^R$-All-Kernel} is exactly the rule for subtyping of bounded quantification found in Kernel F$_{<:}$, that is, 
for $\forall(\alpha \leqslant \tau_1).\tau_1'$ to subtype $\forall(\alpha \leqslant \tau_2).\tau_2'$, $\tau_1$ and $\tau_2$ must be syntactically equivalent.
Contra-variance is allowed only in cases where the type bounds are of the form $\gamma \leqslant \rho$, and thus do not themselves include bounded quantification.
This is captured by the rule \textsc{S$^R$-All}.

The result of this restriction is that subtyping may only introduce new quantified types into the context if they are common to both types.

\subsection{Subtype Decidability}

In order to prove subtype decidability, we define a finite measure on types under a context ($\mathcal{M}(\Gamma, \tau)$), along 
with an ordering ($\mathcal{M}(\Gamma_1, \tau_1) < \mathcal{M}(\Gamma_2, \tau_2)$). 
We subsequently demonstrate that for any calls to a subtype algorithm for F$_{<:}^R$, all resulting subtype calls are strictly 
smaller that the original call.

\subsubsection{Indexed Types}
Before we define our measure $\mathcal{M}$, we introduce an indexing on type variables and types, along with a related invariant on typing contexts.

We index type variables with a natural number, indicating their position in a context.
This is represented as a superscript on type variables: $\alpha^n$ under context $\Gamma$ is the $(n + 1)$th type variable introduced to $\Gamma$ (the first type variable introduced to $\Gamma$ being indexed by 0).
We extend this indexing to types in the form of an upper bound on type variable indices: $\tau^n$ under context
$\Gamma$ indicates that for all $\alpha^i$ occurring in $\tau^n$, $i < n$.
Generally the index $n$ is not important, and so we only include it when relevant.
We further define a simple form of well-formedness:
\begin{definition}[Type Variable Well-Formedness]
A type $\tau^n$ is well-formed under context $\Gamma$ (written $\Gamma \vdash \tau^n\ \texttt{wf}$) 
if and only if $n \leq |\Gamma|$
\end{definition}
We now use this to define a well-formedness property that we assume on all typing contexts:
\begin{definition}[Typing Context Well-Formedness]
\label{def:ctxwf}
A typing context $\Gamma$ is well-formed (written $\Gamma\ \texttt{wf}$) if and only if
for all $(\alpha^n \leqslant \tau^i) \in \Gamma$ we have $i < n$.
\end{definition}
That is, a type bound $\tau$ in a typing context $\Gamma$ may only contain occurrences of type variables that were 
already in $\Gamma$ when $\tau$ was added to it.

Note that indices on types are not unique, and are only an upper bound on type variable occurrences. i.e. if we are able to write $\tau^n$, 
and $n < m$, then we are equally able to write $\tau^m$.
Finally, we use this to define an indexing on typing contexts.
\begin{definition}[Indexed Typing Context]
\label{def:indexedCtx}
$$\Gamma^n \triangleq \{ (\alpha^i \leqslant \tau) | (\alpha^i \leqslant \tau) \in  \Gamma \ \text{and}\ i \leq n\}$$
\end{definition}

\subsubsection{A Finite Measure on Types}


$\mathcal{M}(\Gamma, \tau)$ is defined as a lexicographic ordering on the quantification size and the quantification depth of $\tau$
under $\Gamma$. That is, $\mathcal{M}$ is defined using two simpler measures: 
\begin{enumerate}
\item
$\mathcal{D}(\Gamma, \tau)$ (see Figure \ref{f:quantDepth}): the depth at which the the next quantified type occurs in $\tau$, and
\item
$\mathcal{Q}(\Gamma, \tau)$ (see Figure \ref{f:quantSize}): the number of quantified types in $\tau$ under context $\Gamma$.
\end{enumerate}

$\mathcal{D}$, or quantification depth is defined in Figure \ref{f:quantDepth} as the maximum depth at which the next 
quantification type occurs. $\mathcal{D}$ is also necessarily finite, since it is bounded by the sizes the context $\Gamma$ 
and type $\tau$. Note: we assume a simple well-formedness property, that type variables in the context only refer to 
types lower down in the context, this allows us to disregard $\Gamma''$ in the definition of $\mathcal{D}(\Gamma, \alpha)$.

$\mathcal{Q}(\tau)$, or quantification size of a type is defined in Figure \ref{f:quantSize} as the number of syntactic instances of quantification 
within some $\tau$. It is simple to demonstrate that $\mathcal{Q}$ is finite, as it is bound by the (finite) size of $\tau$.
We then define $\mathcal{Q}(\Gamma, \tau)$, as 
the quantification size of both the type $\tau$, and all types in the context $\Gamma$. Since context arising from 
type checking must be finite, it follows that $\mathcal{Q}(\Gamma, \tau)$ must also be finite.

\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcl}
\mathcal{D}(\Gamma, \top)
			& =
			& 0 \\
\mathcal{D}(\Gamma, \alpha)
			& =
			& 1 + \mathcal{D}(\Gamma', \tau) \\

			&
			& \textit{where}\ \Gamma = \Gamma', (\alpha \leqslant \tau), \Gamma'' \\
\mathcal{D}(\Gamma, \tau_1 \rightarrow \tau_2)
			& =
			& 1 + max(\mathcal{D}(\Gamma, \tau_1), \mathcal{D}(\Gamma, \tau_2)) \\
\mathcal{D}(\Gamma, \forall(\alpha \leqslant \tau_1).\tau_2)
			& =
			& 0
\end{array}
\]
\caption{Quantification Depth: the depth of the next universally quantified type.}
\label{f:quantDepth}
\end{minipage}
\end{figure}
\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcl}
\mathcal{Q}(\top)
			& =
			& 0 \\
\mathcal{Q}(\alpha)
			& =
			& 0 \\
\mathcal{Q}(\tau_1 \rightarrow \tau_1)
			& =
			& \mathcal{Q}(\tau_1) + \mathcal{Q}(\tau_2)  \\
\mathcal{Q}(\forall(\alpha \leqslant \tau_1).\tau_2)
			& =
			& 1 + \mathcal{Q}(\tau_1) + \mathcal{Q}(\tau_2)\\
\mathcal{Q}(\Gamma)
			& =
			& \mathcal{Q}(\tau) + \mathcal{Q}(\Gamma') \\

			&
			& \textit{where}\ \Gamma = \Gamma', (\alpha \leqslant \tau)\\
\mathcal{Q}(\Gamma, \tau^n)
			& =
			& \mathcal{Q}(\Gamma^n) + \mathcal{Q}(\tau^n)
			
\end{array}
\]
\caption{Quantification Size: the number of universally quantified types in a type.}
\label{f:quantSize}
\end{minipage}
\end{figure}

Finally, we define $\mathcal{M}(\Gamma, \tau)$ along with an ordering in Figure \ref{f:measure}.
\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lclr}
\mathcal{M}
			& =
			& \mathcal{Q} \times \mathcal{D} &\\
\textit{and} & & \\
(q_1, d_1) < (q_2, d_2)
			& \iff
			& q_1 < q_2 \ \textit{or} & (1)\\

			&
			&  q_1 = q_2\ \textit{and}\ d_1 < d_2 & (2)
			
\end{array}
\]
\caption{Lexicographic ordering on quantification size and depth.}
\label{f:measure}
\end{minipage}
\end{figure}
$\mathcal{M}(\Gamma, \tau)$ is defined as ($\mathcal{Q}(\Gamma, \tau)$, $\mathcal{D}(\Gamma, \tau)$). 
The key property of $\mathcal{M}$ that guarantees subtype decidability, is the fact that restricted types
have no quantified types as subterms, i.e. 
\begin{property}[Quantification Size of Restricted Types in F$_{<:}^R$]
\label{prop:Qrestricted}
$$\forall \rho, \mathcal{Q}(\rho) = 0$$
\end{property}

\subsubsection{Proof of Decidability}

Since the subtyping defined in Figure \ref{f:sep:subtyping} is syntax directed, the inversion of the rules themselves represent an algorithm for 
subtyping of F$_{<:}^R$. This means that we need not define an algorithm, and are only required to reason about the conclusions of the rules and their premises.
We define \texttt{subtype}$_{F_{<:}^R}$ as the algorithm obtained by inverting the rules in Figure \ref{f:sep:subtyping}.
Theorem \ref{thm:FRdecidability} provides a proof of decidability of subtyping in F$_{<:}^R$.

\begin{theorem}[Subtype Decidability of F$_{<:}^R$]
\label{thm:FRdecidability}
For all $\Gamma$, $\tau_1$, and $\tau_2$, \texttt{subtype}$_{F_{<:}^R}$($\Gamma$, $\tau_1$, $\tau_2$) is guaranteed to terminate.
\end{theorem}
\begin{proof}
Termination of \texttt{subtype}$_{F_{<:}^R}$ is easy to demonstrate by showing that $\mathcal{M}$ represents a 
strictly decreasing measure on subtyping.
That is, for any subtype check 
$$\texttt{subtype}_{F_{<:}^R}(\Gamma, \tau_1, \tau_2)$$
for any resulting calls
$$\texttt{subtype}_{F_{<:}^R}(\Gamma', \tau_1', \tau_2')$$
we have 
$$\mathcal{M}(\Gamma', \tau_1') + \mathcal{M}(\Gamma', \tau_2') < \mathcal{M}(\Gamma, \tau_1) + \mathcal{M}(\Gamma, \tau_2)$$

Since \texttt{subtype}$_{F_{<:}^R}$ is defined as the inversion of the rules in Figure \ref{f:sep:subtyping}, 
the above property is demonstrated by showing that the size of the premises (as measured by $\mathcal{M}$)
of each rule is strictly smaller than the size of the conclusion. In most cases it is fairly simple to demonstrate
this invariant, however in the cases of \textsc{S$^R$-Var} and \textsc{S$^R$-All}, the result is not necessarily so obvious.
\begin{case}[\textsc{S$^R$-Var}]
\begin{mathpar}
\infer
	{
	(\alpha\ \leqslant\ \tau')\ \in\ \Gamma \\
	\Gamma \vdash \tau'\ <:^R \tau
	}
	{\Gamma \vdash \alpha\ <:^R\ \tau}
	\quad (\textsc{S$^R$-Var})
\end{mathpar}
The only sub proof that we need demonstrate our invariant for is $\Gamma \vdash \tau'\ <:^R\ \tau$. That is, we need 
to show that 
$$(\mathcal{Q}(\Gamma, \tau') + \mathcal{Q}(\Gamma, \tau), \mathcal{D}(\Gamma, \tau') + \mathcal{D}(\Gamma, \tau))\ <\
(\mathcal{Q}(\Gamma, \alpha) + \mathcal{Q}(\Gamma, \tau), \mathcal{D}(\Gamma, \alpha) + \mathcal{D}(\Gamma, \tau))$$
Since $\mathcal{Q}(\Gamma,\tau)$ and $\mathcal{D}(\Gamma, \tau)$ fall on both sides of the ordering, it is sufficient to show that 
$$(\mathcal{Q}(\Gamma, \tau'), \mathcal{D}(\Gamma, \tau'))\ <\
(\mathcal{Q}(\Gamma, \alpha), \mathcal{D}(\Gamma, \alpha))$$

 $\Gamma$ is in fact an ordered list of type variable bounds, and thus $(\alpha\ \leqslant\ \tau')\ \in\ \Gamma$ is equivalent to 
asserting that there exists some $\Gamma'$ and $\Gamma''$ such that $\Gamma = \Gamma', (\alpha \leqslant \tau'), \Gamma''$.
Now from the definition of $\mathcal{D}$ we have that 
$$\mathcal{D}(\Gamma, \alpha) = 1 + \mathcal{D}(\Gamma', \tau')$$
Therefore, clearly $\mathcal{D}(\Gamma, \alpha) > \mathcal{D}(\Gamma', \tau')$, and since $\Gamma$ (and thus $\Gamma'$) is 
ordered all variables in $\tau'$ are mapped within $\Gamma'$, and $\mathcal{D}(\Gamma, \tau') = \mathcal{D}(\Gamma', \tau')$, 
giving us 
$$\mathcal{D}(\Gamma, \alpha) > \mathcal{D}(\Gamma, \tau')$$

To show that $\mathcal{Q}$ obeys our invariant, we make use of the well-formedness of typing contexts that we defined in 
Definition \ref{def:ctxwf}. That is, whenever we retrieve a type bound from a well-formed typing context, the index of that 
type bound is strictly smaller than that of the associated type variable. Suppose that $\alpha$ above is indexed by some $n$ 
By definition 
$$\mathcal{Q}(\Gamma, \alpha^n) = \mathcal{Q}(\Gamma^n) + \mathcal{Q}(\alpha^n)$$
Further, by Definition \ref{def:ctxwf} we know there exists some $i$ such that $i < n$ and
$$\mathcal{Q}(\Gamma, \tau^i) = \mathcal{Q}(\Gamma^i) + \mathcal{Q}(\tau^i)$$
Since $i < n$ and $n \leq n$, by Definition \ref{def:indexedCtx} we know that 
$$\Gamma^i  \cup \{(\alpha^n \leqslant \tau^i)\}\  \subseteq\ \Gamma^n$$
Therefore, 
$$\mathcal{Q}(\Gamma^n) \geq \mathcal{Q}(\Gamma^i) + \mathcal{Q}(\tau^i)$$
and finally we get 
$$\mathcal{Q}(\Gamma^n) + \mathcal{Q}(\alpha^n) \geq \mathcal{Q}(\Gamma^i) + \mathcal{Q}(\tau^i)$$
\end{case}
\begin{case}[\textsc{S$^R$-All}]
\begin{mathpar}
\infer
	{
	\Gamma \vdash \rho_2\ <:^R\ \rho_1 \\
	\Gamma, (\gamma \leqslant \rho_2) \vdash \tau_1\ <:^R\ \tau_2
	}
	{\Gamma \vdash \forall (\gamma\leqslant\rho_1).\tau_1\ <:^R\ \forall(\gamma \leqslant \rho_2).\tau_2}
	\quad (\textsc{S$^R$-All})
\end{mathpar}
Firstly, it is simple to show that 
$$\mathcal{M}(\Gamma, \rho_1) + \mathcal{M}(\Gamma, \rho_2) < \mathcal{M}(\Gamma, \forall (\gamma\leqslant\rho_1).\tau_1) + \mathcal{M}(\Gamma, \forall(\gamma \leqslant \rho_2).\tau_2)$$
Secondly, the key observation is that by Property \ref{prop:Qrestricted} we know that 
$$\mathcal{Q}(\gamma_1) = \mathcal{Q}(\gamma_2) = 0$$
As a result we also have that 
$$\mathcal{Q}(\Gamma, (\gamma \leqslant \rho_2) = \mathcal{Q}(\Gamma))$$
Thus we have
$$\mathcal{Q}(\Gamma, (\gamma \leqslant \rho_2), \tau_1) + \mathcal{Q}(\Gamma, (\gamma \leqslant \rho_2), \tau_2) = \mathcal{Q}(\Gamma, \tau_1) + \mathcal{Q}(\Gamma, \tau_2)$$
It is thus simple to show that
$$\mathcal{Q}(\Gamma, \tau_1) + \mathcal{Q}(\Gamma, \tau_2) < \mathcal{Q}(\Gamma, \forall (\gamma\leqslant\rho_1).\tau_1) + \mathcal{Q}(\Gamma, \forall(\gamma \leqslant \rho_2).\tau_2)$$
and subsequently we get the desired result.
\end{case}
\end{proof}

\subsection{Typing and Operational Semantics}

In this section we briefly introduce the term syntax, typing, and operational semantics of \Fsub. The term 
syntax is defined in Figure \ref{f:fsub:terms}. A term in F$_{<:}^R$

\begin{figure}[t]
\[
\begin{array}{lcr}
\begin{syntax}
\syntaxElement{t}{F$_{<:}$ Term}
	{\lambda (x : \tau).t}{abstraction}
	{t\ t}{application}
	{\Lambda(\alpha \leqslant \tau).t}{type abstraction}
	{t\ \tau}{type application}
\endSyntaxElement 
\end{syntax}
&

&
\begin{syntax}
\syntaxElement{E}{Evaluation Context}
	{\bigcirc}{hole}
	{E\ t}{}
	{t\ E}{}
	{E\ \tau}{}
\endSyntaxElement
\end{syntax}
\end{array}
\]
\caption{\Fsub Term Syntax}
\label{f:fsub:terms}
\end{figure}

\subsubsection{Term Typing}

\begin{figure}[t]
\begin{mathpar}
\infer{\Delta(x)\ =\ \tau}
      {\Delta; \Gamma \vdash x\ :\ \tau}
      \quad (\textsc{T-Var})
      \and
\infer{\Delta, x : \tau; \Gamma \vdash e\ :\ \tau'}
      {\Delta; \Gamma \vdash \lambda x : \tau.e\ :\ \tau \rightarrow \tau'}
      \quad (\textsc{T-Abs})
      \and
\infer{\Delta; \Gamma \vdash e\ :\ \tau' \rightarrow \tau \\\\
			\Delta; \Gamma \vdash e'\ :\ \tau'}
      {\Delta; \Gamma \vdash e\ e'\ :\ \tau}
      \quad (\textsc{T-App})
      \and
\infer{\Delta; \alpha \leqslant \tau; \Gamma \vdash e\ :\ \tau'}
      {\Delta; \Gamma \vdash \Lambda (\alpha \leqslant\tau).e\ :\ \forall (\alpha\leqslant\tau).\tau'}
      \quad (\textsc{T-Type-Abs})
      \and
\infer{\Delta; \Gamma \vdash e\ :\ \forall \alpha\leqslant\tau'.\tau'' \\
			\Delta \vdash \tau\ <:\ \tau'}
      {\Delta; \Gamma \vdash e\ \tau\ :\ [\tau / \alpha]\tau''}
      \quad (\textsc{T-Type-App})
      \and
\infer{\Delta; \Gamma \vdash e\ :\ \tau' \\
			\Delta \vdash \tau'\ <:\ \tau}
      {\Delta; \Gamma \vdash e\ :\ \tau}
      \quad (\textsc{T-Sub})
\end{mathpar}
\caption{\Fsub Type Rules}
\label{f:fsubTyping}
\end{figure}

\subsubsection{Operational Semantics}
\begin{figure}[t]
\begin{mathpar}
\infer{}
      {\lambda x.t\ \longrightarrow\ \lambda y.[y / x]t}
      \quad (\alpha-\textsc{conversion})
      \and
\infer{}
      {(\lambda x.t_1)\ t_2\ \longrightarrow\ [t_2 / x]t_1}
      \quad (\beta-\textsc{reduction})
      \and
\infer{}
      {\Lambda \alpha. t\ \tau\  \longrightarrow [\tau / \alpha]t}
      \quad (\textsc{R-Type-App})
\end{mathpar}
\caption{\Fsub Operational Semantics}
\label{f:opSemantics}
\end{figure}

%\begin{case}[\textsc{S$^R$-Top}]
%Trivial.
%\end{case}
%\begin{case}[\textsc{S$^R$-Rfl}]
%Trivial.
%\end{case}
%\begin{case}[\textsc{S$^R$-Var}]
%\begin{mathpar}
%\infer
%	{
%	(\alpha\ \leqslant\ \tau)\ \in\ \Gamma \\
%	\Gamma \vdash \tau'\ <: \tau
%	}
%	{\Gamma \vdash \alpha\ <:\ \tau}
%	\quad (\textsc{S$^R$-Var})
%\end{mathpar}
%It is enough to show that $\mathcal{M}(\Gamma, \tau) < \mathcal{M}(\Gamma, \alpha)$. 
%By context well-formedness (Definition \ref{def:ctxwf}) we know that 
%$$\mathcal{Q}(\Gamma, \tau) \leq \mathcal{Q}(\Gamma, \alpha)$$
%Further, by definition of $\mathcal{D}$ we have
%$$\mathcal{D}(\Gamma, \tau) \leq \mathcal{D}(\Gamma, \alpha)$$
%giving us the desired result.
%\end{case}


\subsection{Properties of F$_{<:}^R$}

One of the most useful aspects of F$_{<:}^R$, is that it represents a subset of \Fsub.
That is, not only is any type $\tau$ in F$_{<:}^R$ also a type in \Fsub, but subtyping in F$_{<:}^R$
implies subtyping in \Fsub, and typing in F$_{<:}^R$ implies typing in \Fsub. This means that F$_{<:}^R$
inherits several useful properties of \Fsub metatheory.

In this Section, we discuss some of the properties of F$_{<:}^R$, and in doing so, we refer to both the
typing judgment, and operational semantics. These are identical to those of \Fsub, and so are not 
given here, but are provided in the accompanying Appendices (see Appendix \ref{app:fsub}). As with 
subtyping, we often need to refer to several different forms of typing, and we make this distinction
by annotating the judgment appropriately. Typing in \Fsub is indicated as $\Gamma \vdash \tau_1\ :\ \tau_2$, 
and in F$_{<:}^R$ as $\Gamma \vdash \tau_1\ :^R\ \tau_2$.

\subsubsection{Subtype Transitivity}

Unlike other variants on \Fsub \cite{10.1145/3371077}, F$_{<:}^R$ retains the subtype transitivity of
\Fsub.

\begin{theorem}[Subtype Transitivity  in F$_{<:}^R$]
For all $\tau_1$, $\tau_2$, and $\tau_3$, if $\Gamma \vdash \tau_1\ <:^R\ \tau_2$ and $\Gamma \vdash \tau_2\ <:^R\ \tau_3$, then
$\Gamma \vdash \tau_1\ <:^R\ \tau_3$.
\end{theorem}

\subsubsection{Subtyping in F$_{<:}^R$ $\subset$ Subtyping in \Fsub}

F$_{<:}^R$ is not a significant change to the semantics of bounded quantification 
from \Fsub, in fact subtyping in F$_{<:}^R$ is a subset of subtyping in \Fsub. That 
is any subtyping that can be derived in F$_{<:}^R$ can also be derived in \Fsub.

\begin{theorem}[F$_{<:}^R$ $\subset$ \Fsub]
For all $\Gamma$, $\tau_1$, and $\tau_1$, if $\Gamma \vdash \tau_1\ <:^R\ \tau_2$ then 
$\Gamma \vdash \tau_1\ <:^N\ \tau_2$.
\end{theorem}

This is a useful property because it implies that existing type checkers need only 
introduce syntactic checks at key points (when checking subtyping between quantified types with different bounds), 
and do not need significant modifications
to the subtyping algorithm.

\subsubsection{Subtyping in Kernel F$_{<:}$ $\subset$ Subtyping in F$_{<:}^R$}

F$_{<:}^R$ represents a super set of Kernel F$_{<:}$ in terms of subtyping.
This provides a useful lower bound on expressiveness. Any valid Kernel F$_{<:}$ program 
is also a valid F$_{<:}^R$ program.

\begin{theorem}[Kernel F$_{<:}$ $\subset$ F$_{<:}^R$]
For all $\Gamma$, $\tau_1$, and $\tau_1$, if $\Gamma \vdash \tau_1\ <:^K\ \tau_2$ then 
$\Gamma \vdash \tau_1\ <:^R\ \tau_2$.
\end{theorem}

\subsubsection{Type Safety}
As subtyping in F$_{<:}^R$ is a subset of subtyping in \Fsub, and the two calculi have otherwise identical 
typing, it follows that every well-typed program in F$_{<:}^R$ is well-typed in \Fsub. It is thus unsurprising 
that given \Fsub's type safety, and that the two calculi have identical operational semantics, any well-typed 
F$_{<:}^R$ program is guaranteed to not get stuck. In other words, F$_{<:}^R$ is type safe. 
\begin{theorem}[Type Safety]
For all $\Gamma$, $t$ and $\tau$, if $\Gamma \vdash t\ :^R\ \tau$, then reduction of $t$ is guaranteed to 
not get stuck.
\end{theorem}
While this is an important result, it is also notable 
that F$_{<:}^R$ retains the subject reduction property \cite{10.1006/inco.1994.1093} 
(sometimes called preservation).
\begin{theorem}[Subject Reduction]
For all $\Gamma$, $t_1$, $t_2$ and $\tau_1$, if $\Gamma \vdash t_1\ :^R\ \tau_1$ and $t_1\ \longrightarrow\ t_2$,
then there exists $\tau_2$ such that $\Gamma \vdash t_2\ :^R\ \tau_2$ and $\Gamma \vdash \tau_1\ <:^R\ \tau_2$.
\end{theorem}
Subject reduction is useful as a property beyond the type safety of F$_{<:}^R$, as it means that designers of 
extensions to the calculus might make use of the convenience of a small-step semantics in demonstrating 
type safety in the presence of new language features.


\subsubsection{Minimal Typing}

As mentioned in Section \ref{s:background} F$_{<:}^\top$ \cite{10.1145/174675.177844} is another variant of \Fsub that allows for 
subtyping of bounded quantification that is both decidable and contra-variant on type bounds. We also mentioned 
that typing in F$_{<:}^\top$ is not minimal \cite{10.1145/199448.199539}, and thus some terms can be typed with two different types that are not
related by subtyping. Specifically, in F$_{<:}^\top$, the term $t = \Lambda (X \leqslant \texttt{Int}).\lambda(x : X).x$
can be shown to have both the type $\tau_1 = \forall(X \leqslant \texttt{Int}).X \rightarrow X$, and the type
$\tau_2 = \forall(X \leqslant \texttt{Int}).X \rightarrow \texttt{Int}$. In F$_{<:}^\top$, these two types are unrelated, and have 
no lower bound. The implications of this lack of minimality are that the standard typing  algorithm for \Fsub is not complete
for F$_{<:}^\top$, and will assign $t$ one type, but not the other, and any usage where $t$ is required to be typed with
both types will not type check.

The reason for the loss of minimal typing in F$_{<:}^\top$ is due to a ``rebounding'' of type variables during subtyping 
to $\top$. Subtyping of the body of a quantified type is done with reduced type information as the bound of the 
type variable is treated as $\top$, hiding the relationship between the type variable and it's bound.

A central motivation in designing F$_{<:}^R$ is to provide reliable and expected behavior to type checkers, that allows for understandable
error messages in type checking. The loss of minimal typing does not provide these assurances. For instance, it seems reasonable to 
expect that in the example above, $\tau_1$ should subtype $\tau_2$, and if it doesn't a satisfying reason should be 
provided by the type checker. Subtyping in F$_{<:}^R$ does not perform the same ``rebounding'', and as a result does 
not suffer from the same loss of minimal typing.

\begin{theorem}[Minimal Typing]
For all $\Gamma$, $t$, $\tau_1$, and $\tau_2$, if $\Gamma \vdash t\ :^R\ \tau_1$ and $\Gamma \vdash t\ :^R\ \tau_2$, 
then there exists some $\tau$, such that  $\Gamma \vdash t\ :^R\ \tau$, $\Gamma \vdash \tau\ <:^R\ \tau_1$, and 
$\Gamma \vdash \tau\ <:^R\ \tau_2$.
\end{theorem}




%\section{Relaxing the Constraints on \Fsub}
%
%
%
%
%
%\begin{figure}[t]
%\begin{minipage}{\linewidth}
%\[
%%\begin{array}{lcr}
%\begin{syntax}
%\syntaxElement{\gamma}{System F Type}
%	{\top}{top}
%	{\alpha}{variable}
%	{\gamma \rightarrow \gamma}{arrow}
%	{\forall \alpha.\tau}{all}
%\endSyntaxElement
%\end{syntax}
%\]
%\caption{System F Type Syntax}
%\label{f:sysf:syntax}
%\end{minipage}
%\end{figure}

\section{Separating D$_{<:}$}

D$_{<:}$ is a calculus related to \Fsub that includes abstract type members and dependent functions, and serves to model core aspects of 
the Scala type system. The syntax of D$_{<:}$ is given in Figure \ref{f:dsub:syntax}, and at first glance does not immediately resemble 
that of \Fsub. Most noticably, D$_{<:}$ does not include any type variables. The expressiveness of D$_{<:}$ derives from being able to capture
\Fsub using  path types ($x.L$) and dependent function types ($\allType{x}{\tau_1}{\tau_2}$). 

\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{syntax}
\syntaxElement{\tau}{D$_{<:}$ Type}
	{\top}{top}
	{\bot}{bottom}
	{\nonRec{}{\typeDef{L}{\tau}{\tau}}}{declaration}
	{x.L}{selection}
	{\allType{x}{\tau}{\tau^x}}{function}
\endSyntaxElement 
\end{syntax}
\]
\caption{D$_{<:}$ Type Syntax}
\label{f:dsub:syntax}
\end{minipage}
\end{figure}
A type in D$_{<:}$  is either $\top$, $\bot$, a type dclaration $\nonRec{}{\typeDef{L}{\tau_1}{\tau_2}}$, a selection type $x.L$, or a dependent function type $\allType{x}{\tau_1}{\tau_2^x}$.

In D$_{<:}$, type declarations ($\nonRec{}{\typeDef{L}{\tau_1}{\tau_2}}$) define a type. Given a path $x$ to the type definition, 
the defined type can be used by selection on the path: $x.L$. That is, if value $x$ has type $\nonRec{}{\typeDef{L}{\tau_1}{\tau_2}}$, then $x.L$ 
refers to the defined type, where $\tau_1$ is the lower bound, and $\tau_2$ the upper bound.
This is useful when combined with the dependent function types of D$_{<:}$.
The return types of functions in D$_{<:}$  can be dependent on the argument. This dependence is indicated in the syntax by a super-script of the 
variable identifying the argument. i.e. $\allType{x}{\tau_1}{\tau_2^x}$ indicates that $x$ is free in $\tau_2$.

\begin{figure}[t]
\small
\begin{mathpar}
\infer
	{}
	{\Gamma  \vdash \tau\ <:^D\ \top}
	\quad (\textsc{Top})
	\and
\infer
	{}
	{\Gamma  \vdash \bot\ <:^D\ \tau}
	\quad (\textsc{Bot})
	\and
\infer
	{}
	{\Gamma  \vdash \tau\ <:^D\ \tau}
	\quad (\textsc{Rfl})
	\and
\infer
	{
	\Gamma(x) = \nonRec{}{\typeDef{L}{\tau_1}{\tau_2}}
	}
	{\Gamma  \vdash x.L\ <:^D\ \tau_2}
	\quad (\textsc{Sel1})
	\and
\infer
	{
	\Gamma(x) = \nonRec{}{\typeDef{L}{\tau_1}{\tau_2}}
	}
	{\Gamma  \vdash \tau_1\ <:^D\ x.L}
	\quad (\textsc{Sel2})
	\and
\infer
	{
	\Gamma \vdash \tau_1\ <:^D\ \tau_2 \\
	\Gamma \vdash \tau_2\ <:^D\ \tau_3
	}
	{\Gamma  \vdash \tau_1 \ <:^D\ \tau_3}
	\quad (\textsc{Trans})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^D\ \tau_1 \\
	\Gamma \vdash \tau_1'\ <:^D\ \tau_2'
	}
	{\Gamma  \vdash \nonRec{}{\typeDef{L}{\tau_1}{\tau_1'}} \ <:^D\ \nonRec{}{\typeDef{L}{\tau_2}{\tau_2'}}}
	\quad (\textsc{Bnd})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^D\ \tau_1 \\
	\Gamma, (x : \tau_2) \vdash \tau_1'\ <:^D\ \tau_2'
	}
	{\Gamma  \vdash \allType{x}{\tau_1}{\tau_1'} \ <:^D\ \allType{x}{\tau_2}{\tau_2'}}
	\quad (\textsc{All})
\end{mathpar}
\caption{D$_{<:}$ Subtyping}
\label{f:dsub:subtyping}
\end{figure}
D$_{<:}$ subtyping is defined in Figure \ref{f:dsub:subtyping}, and is indicated by $\Gamma \vdash \tau_1\ <:^D\ \tau_2$. Subtyping is bound above by $\top$ (\textsc{Top}) and below by $\bot$ (\textsc{Bot}).
Subtyping is explicitly reflexive (\textsc{Rfl}). Selection types subtype their upper bounds (\textsc{Sel1}), and super type their lower bounds (\textsc{Sel2}).
Subtyping of type declarations are contra-variant with respect to the lower bounds, and covariant with respect to their upper bounds (\textsc{Bnd}).
Finally, subtyping of dependent fuction types is contra-variant with respect to the arument types, and covariant with respect to the return types, 
with the return types being dependent on the arguments (\textsc{All}).

Coupling type declarations together with dependent function types allows for similar functionality to F$_{<:}$. That is, we can use the encoding below to capture 
bounded quantification from \Fsub in D$_{<:}$.
\[
\begin{array}{lcl}
\llbracket\top\rrbracket 
		& \triangleq 
		& \top\\
\llbracket\alpha\rrbracket 
		& \triangleq 
		& x_\alpha.A\\
\llbracket\tau_1 \rightarrow \tau_2\rrbracket 
		& \triangleq 
		& \allType{x_\alpha}{\llbracket\tau_1\rrbracket}{\llbracket\tau_2\rrbracket^{x_\alpha}}\\
\llbracket\forall(\alpha\leqslant\tau_1).\tau_2\rrbracket 
		& \triangleq 
		& \allType{x_\alpha}{\nonRec{}{\typeDef{A}{\bot}{\llbracket\tau_1\rrbracket}}}{\llbracket\tau_2\rrbracket^{x_\alpha}}
\end{array}
\]
The above encoding is in fact not enough to demonstrate the undecidability of D$_{<:}$ due to the fact that while the following holds:
\[
\Gamma \vdash \tau_1\ <:^D\ \tau_2\ \Rightarrow\ \llbracket\Gamma\rrbracket \vdash \llbracket\tau_1\rrbracket\ <:^N\ \llbracket\tau_2\rrbracket
\]
the inverse does not.
\[
\llbracket\Gamma\rrbracket \vdash \llbracket\tau_1\rrbracket\ <:^N\ \llbracket\tau_2\rrbracket\ \not\Rightarrow\ \Gamma \vdash \tau_1\ <:^D\ \tau_2
\]
The reasons for this are due to the fact that functions in \Fsub are unrelated to universally quantified types, 
but in D$_{<:}$ they are both captured using dependent function types. The full proof for this was demonstrated 
by Hu and Lhot\'{a}k \cite{10.1145/3371077}, but this does not affect the undecidability result for D$_{<:}$, as the proof of undecidability 
in \Fsub does not rely on function types.


Figure \ref{f:dsub:separated:syntax} presents the syntax for D$_{<:}^R$,  a separated variant of 
D$_{<:}$. D$_{<:}^R$ introduces a similar separation on syntax to that of F$_{<:}^R$. Where 
F$_{<:}^R$ places a restriction on the bounds of type variables, D$_{<:}^R$ places a restriction on 
the bounds of type members. That is, we distinguish restricted type definitions from unrestricted ones.
A restricted type definition ($\nonRec{}{\typeDef{R}{\rho_1}{\rho_2}}$) is a type definition that does not
contain any dependent function types in either the upper or lower bound. As with F$_{<:}^R$This 
restriction is indicated by restricted types ($\rho$). Note: restricted types are only separated from 
dependent function types, and not function types in general. As we have already mentioned, 
dependent functions in D$_{<:}$ capture both abstraction over values and abstraction over types, 
while in \Fsub, bounded polymorphism only captures abstraction over types. 
\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcr}
\begin{syntax}
\syntaxElement{\tau}{D$_{<:}^R$ Type}
	{\top}{top}
	{\bot}{bottom}
	{\nonRec{}{\typeDef{U}{\tau}{\tau}}}{declaration}
	{\nonRec{}{\typeDef{R}{\rho}{\rho}}}{declaration}
	{x.L}{selection}
	{\allType{x}{\tau}{\tau^x}}{dependent function}
\endSyntaxElement
\end{syntax}
&
~~~~~~~
&
\begin{syntax}
\syntaxElement{L}{Type Label}
	{U}{unrestricted}
	{R}{restricted}
\endsyntaxElement\\
\syntaxElement{\rho}{D$_{<:}^R$ Restricted Type}
	{\top}{top}
	{\bot}{bottom}
	{\nonRec{}{\typeDef{L}{\rho}{\rho}}}{declaration}
	{\allType{x}{\rho}{\rho}}{function}
	{x.R}{selection}
\endSyntaxElement  \\
\end{syntax}
\end{array}
\]
\caption{D$_{<:}^R$ Type Syntax}
\label{f:dsub:separated:syntax}
\end{minipage}
\end{figure}

\subsection{Restricted Subtyping in D$_{<:}^R$}

\begin{figure}[t]
\small
\begin{mathpar}
\infer
	{}
	{\Gamma  \vdash \tau\ <:^R\ \top}
	\quad (\textsc{Top$^R$})
	\and
\infer
	{}
	{\Gamma  \vdash \bot\ <:^R\ \tau}
	\quad (\textsc{Bot$^R$})
	\and
\infer
	{}
	{\Gamma  \vdash x.L\ <:^R\ x.L}
	\quad (\textsc{Rfl$^R$})
	\and
\infer
	{
	\Gamma(x) = \nonRec{}{\typeDef{L}{\tau_1}{\tau_2}} \\
	\Gamma \vdash \tau_2\ <:\ \tau
	}
	{\Gamma  \vdash x.L\ <:^R\ \tau}
	\quad (\textsc{Sel1$^R$})
	\and
\infer
	{
	\Gamma(x) = \nonRec{}{\typeDef{L}{\tau_1}{\tau_2}} \\
	\Gamma \vdash \tau\ <:\ \tau_1
	}
	{\Gamma  \vdash \tau\ <:^R\ x.L}
	\quad (\textsc{Sel2$^R$})
	\and
\infer
	{
	\Gamma \vdash \tau_2\ <:^R\ \tau_1 \\
	\Gamma \vdash \tau_1'\ <:^R\ \tau_2'
	}
	{\Gamma  \vdash \nonRec{}{\typeDef{L}{\tau_1}{\tau_1'}} \ <:^R\ \nonRec{}{\typeDef{L}{\tau_2}{\tau_2'}}}
	\quad (\textsc{Bnd$^R$})
	\and
\infer
	{
	\Gamma \vdash \tau_1\ <:^R\ \tau_2
	}
	{\Gamma  \vdash \allType{x}{\tau}{\tau_1} \ <:^R\ \allType{x}{\tau}{\tau_2}}
	\quad (\textsc{All-Kernel$^R$})
	\and
\infer
	{
	\Gamma \vdash \rho_2\ <:^R\ \rho_1 \\
	\Gamma, (x : \rho_2) \vdash \tau_1\ <:^R\ \tau_2
	}
	{\Gamma  \vdash \allType{x}{\tau_1}{\tau_1'} \ <:^R\ \allType{x}{\tau_2}{\tau_2'}}
	\quad (\textsc{All$^R$})
\end{mathpar}
\caption{D$_{<:}^R$ Subtyping}
\label{f:dsubR:subtyping}
\end{figure}

Subtyping for D$_{<:}^R$ is defined in Figure \ref{f:dsubR:subtyping}. There are several differences between the 
restricted form of subtyping and that of D$_{<:}$. As with bounded quantification in F$_{<:}^R$, subtyping of 
dependent function types in D$_{<:}^R$ can be proven using one of two rules: (i) \textsc{Kernel-All$^R$}, a subtype
rule that enforces invariance on the argument type, and (ii) \textsc{All$^R$}, a subtype rule that allows covariance
on function argument types of the form $\rho$. 

Subtyping in D$_{<:}^R$ also differs from standard D$_{<:}$ subtyping in how reflexivity and transitivity are formalized.
Explicit subtype reflexivity in D$_{<:}^R$ is restricted to type selections ($x.L$). This is similar to the modification F$_{<:}^N$
makes to traditional \Fsub. 

\subsubsection{Subtype Transitivity}
As in F$_{<:}^N$, the explicit transitivity rule, \textsc{Trans}, is removed. Transitivity 
rules are generally difficult to design an algorithm for as it is not always clear what to choose for the middle type ($\tau_2$ in Trans).
To try and recapture some level of transitivity, we modify the subtype rules for upper and lower bounds  by introducing a 
level of transitivity (see \textsc{Sel1$^R$} and \textsc{Sel2$^R$} in Figure \ref{f:dsubR:subtyping}). This mirrors the difference
in transitivity between the F$_{<:}^N$ version of \Fsub subtyping, and the original definition of Cardelli \cite{cardelli1991}, 
where the explicit transitivity rule was removed, and replaced with a modified rule for type variable subtyping that accounted 
for transitivity. In the F$_{<:}^N$ (and F$_{<:}^R$) rule set, general transitivity is provable as a property of subtyping. Unfortunately 
the same cannot be said for D$_{<:}^R$. Subtyping in D$_{<:}^R$ is not transitive. 

The reason for the loss of transitivity is due to the the relationship between the upper and lower bounds of type definitions:
there is no requirement that the lower bound subtypes the upper bound. Precursor calculi to D$_{<:}$ attempted to 
enforce this invariant, but due to a complex set of reasons, this is not generally possible in the presence of another Scala 
feature: intersection types. A critical insight of previous work on the DOT calculus, is that ill-formed type bounds not 
necessarily unsound \cite{amin2012dependent, Amin:2014:FPT:2660193.2660216, Rompf:2016:TSD:2983990.2984008} since ultimately at run-time, any type bounds must be fulfilled by some value (a witness), 
and only well-formed bounds may be fulfilled. The details are interesting, but are fairly complex and so we do not 
address them further.

\subsection{Subtype Decidability in D$_{<:}^R$}

The subtype decidability  argument for D$_{<:}^R$ is much like that of F$_{<:}^R$: We define an ordering on the number of 
dependent function types and the depth of a type down to the next dependent function type. 
We define the measures $\mathcal{D}$ and $\mathcal{Q}$ in Figures \ref{f:dsub:depfunDepth}
and \ref{f:dsub:depfunSize}. As with F$_{<:}^R$, the finite measure of D$_{<:}^R$ the lexicographic ordering:
$$\mathcal{M} = \mathcal{D} \times \mathcal{Q}$$

\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcl}
\mathcal{D}(\Gamma, \top)
			& =
			& 0 \\
\mathcal{D}(\Gamma, \bot)
			& =
			& 0 \\
\mathcal{D}(\Gamma, x.L)
			& =
			& 1 + max(\mathcal{D}(\Gamma, \tau_1),  \mathcal{D}(\Gamma, \tau_2)) \\

			&
			& \textit{where}\ \Gamma \vdash x\ :\ \nonRec{}{\typeDef{L}{\tau_1}{\tau_2}} \\
\mathcal{D}(\Gamma, \allType{x}{\tau_1}{\tau_2})
			& =
			& 1 + max(\mathcal{D}(\Gamma, \tau_1), \mathcal{D}(\Gamma, \tau_2)) \\
\mathcal{D}(\Gamma, \allType{x}{\tau_1}{\tau_1^x})
			& =
			& 0
\end{array}
\]
\caption{Quantification Depth: the depth of the next dependent function type.}
\label{f:dsub:depfunDepth}
\end{minipage}
\end{figure}

\begin{figure}[t]
\begin{minipage}{\linewidth}
\[
\begin{array}{lcl}
\mathcal{Q}(\top)
			& =
			& 0 \\
\mathcal{Q}(\alpha)
			& =
			& 0 \\
\mathcal{Q}( \allType{x}{\tau_1}{\tau_2})
			& =
			& \mathcal{Q}(\tau_1) + \mathcal{Q}(\tau_2)  \\
\mathcal{Q}( \allType{x}{\tau_1}{\tau_2}^x)
			& =
			& 1 + \mathcal{Q}(\tau_1) + \mathcal{Q}(\tau_2)\\
\mathcal{Q}(\Gamma)
			& =
			& \mathcal{Q}(\tau) + \mathcal{Q}(\Gamma') \\

			&
			& \textit{where}\ \Gamma = \Gamma', (\alpha \leqslant \tau)\\
\mathcal{Q}(\Gamma, \tau^n)
			& =
			& \mathcal{Q}(\Gamma^n) + \mathcal{Q}(\tau^n)
			
\end{array}
\]
\caption{Quantification Size: the number of dependent function types in a D$_{<:}^R$ type.}
\label{f:dsub:depfunSize}
\end{minipage}
\end{figure}

We can now prove subtype decidability for D$_{<:}^R$ using much the same logic as we did for F$_{<:}^R$. 
We define a 
subtype algorithm for D$_{<:}^R$ : \texttt{subtype}$_{D_{<:}^R}$.
As with \texttt{subtype}$F_{<:}^R$, $\texttt{subtype}_{D_{<:}^R}$ is the inversion of the rule set in Figure \ref{f:dsubR:subtyping}.
A sketch of the proof of decidability is given below.

\begin{theorem}[Subtype Decidability of D$_{<:}^R$]
\label{thm:FRdecidability}
For all $\Gamma$, $\tau_1$, and $\tau_2$, \texttt{subtype}$_{D_{<:}^R}$($\Gamma$, $\tau_1$, $\tau_2$) is guaranteed to terminate.
\end{theorem}
\begin{proof}
As with the proof of subtype decidability for F$_{<:}^R$, it is fairly simple to  demonstrate 
that for any call $\texttt{subtype}_{D_{<:}^R}(\Gamma, \tau_1, \tau_2)$, by the measure $\mathcal{M}$,
any resulting calls to $\texttt{subtype}_{D_{<:}^R}$ are strictly smaller.
\end{proof}

\subsection{Type Safety}
Subtyping in D$_{<:}^R$ is a subset of subtyping in D$_{<:}^R$, and as with F$_{<:}^R$, this affords D$_{<:}^R$ 
many of the properties of D$_{<:}$. Type safety is one such property, and arises immediately from Theorem 
\ref{thm:dsubRSubset} below.

\begin{theorem}[D$_{<:}^R$ $\subset$ D$_{<:}$]
\label{thm:dsubRSubset}
For all $\Gamma$, $\tau_1$, and $\tau_1$, if $\Gamma \vdash \tau_1\ <:^R\ \tau_2$ then 
$\Gamma \vdash \tau_1\ <:^D\ \tau_2$.
\end{theorem}


\section{Related Work}

\subsection{Strong F$_{<:}$ and Strong D$_{<:}$}
Hu and Lhot\'{a}k \cite{10.1145/3371077}, defined decidable variants of \Fsub and D$_{<:}$ named Strong F$_{<:}$ and Strong D$_{<:}$ respectively.
Their approach introduced a second typing context to subtyping, one for each type, giving subtyping the following form. 
$$\Gamma_1 \gg \tau_1\ <:\ \tau_2 \ll \Gamma_2$$
Hu and Lhot\'{a}k refer to this as ``stare-at subtyping''. Type bounds in $\tau_1$ are appended to $\Gamma_1$, while type bounds in $\tau_2$ are appended to $\Gamma_2$. 
This separation of contexts ensures that there is no 
problematic ``rebounding'' \cite{Pierce:1992:BQU:143165.143228} that might lead to an expansive context. There are however some short comings to this technique, 
specifically subtype transitivity is lacking in both type systems. Below we demonstrate an instance of subtype transitivity  that is lost in 
Strong F$_{<:}$.
\begin{mathpar}
\infer
	{}
	{A = \forall(\alpha \leqslant \top).\alpha}
	\and
\infer
	{}
	{B = \forall(\alpha \leqslant \texttt{Int}).\alpha}
	\and
\infer
	{}
	{C = \forall(\alpha \leqslant \texttt{Int}).\texttt{Int}}
\end{mathpar}
%$$A = \forall(\alpha \leqslant \top).\alpha$$
%$$B = \forall(\alpha \leqslant \texttt{Int}).\alpha$$
%$$C = \forall(\alpha \leqslant \texttt{Int}).\texttt{Int}$$
While it can be shown that both $A$ subtypes $B$ and $B$ subtypes $C$ in Strong F$_{<:}$, the transitive case cannot be derived, i.e.
$A\ \not<:\ C$. During subtyping of bounded quantification in Strong F$_{<:}$ (and Strong D$_{<:}$), two typing contexts are maintained, each updated with 
the bounds of the relevant type. While subtype reflexivity of type variables allows $\alpha$ to subtype $\alpha$ when deriving $A\ <:\ B$, 
this is not so when attempting to derive $A\ <:\ C$.
This is not an especially complex example, and is a subtyping that programmers might expect to hold.

Using a syntactic separation we are able to retain subtype transitivity in F$_{<:}^R$. The trade off is that we exclude a specific class of 
programs. These programs, however, can be identified syntactically, and thus F$_{<:}^R$ enables the type checker to better guide programmers in fixing their error.

While we have already mentioned that D$_{<:}^R$ is not indeed transitive, this is due to the potential for ``bad bounds'' on type definitions, and 
the problems associated with ensuring ``good bounds''. D$_{<:}^R$ does not exclude the types of transitivity seen in  Strong D$_{<:}$ which lacks transitivity, 
not only due to the ``bad bounds'' problem, but also for the same reasons Strong F$_{<:}$ does. More specifically, the subtyping $A\ <:\ C$ can be 
derived in F$_{<:}^R$. Similarly, the equivalent example in D$_{<:}$ is not derivable in Strong D$_{<:}$, but is derivable in $D_{<:}^R$.



\subsection{Wyvern}

Mackay et al. \cite{10.1145/3371134} defined two decidable variants of Wyvern \cite{Nistor:2013:WST:2489828.2489830, Omar:2014:SCT:2945642.2945649}, a language related to Scala, featuring 
type members, dependent function types, recursive types, and a limited form of intersection types called type refinements.
Their variants of Wyvern were named \WFix and \WSelf, and took different approaches to ensuring decidability.

Interestingly, \WFix introduces essentially the same double headed form of subtyping that Hu and Lhot\'{a}k \cite{10.1145/3371077} did. 
An independent discovery, Mackay et. al  \cite{10.1145/3371134} use the the double headed subtyping form in a slightly different setting 
with the same purpose. While the Strong Kernel D$_{<:}$ of Hu and Lhot\'{a}k \cite{10.1145/3371077} does not include recursive types
or any form of intersection types, \WFix does. \WFix suffers from the same loss of transitivity that Strong Kernel D$_{<:}$ does, 
and as such prohibits several useful forms of expressiveness.

\WSelf does not use a double headed form, and rather makes use of a Material/Shape separation inspired by the work of
Greenman et al. \cite{Greenman:2014:GFP:2594291.2594308}. \WSelf does not allow for contra-variance on the argument types of 
dependent functions.


\section{Conclusion}

In this paper we have presented F$_{<:}^R$, a variant of \Fsub that is decidable in it's subtyping, while retaining several of the desirable qualities of 
\Fsub. Our approach is largely in the form of a syntactic restriction on types, rather than  a significant departure from the semantics of
subtyping bounded quantification. Further, we have shown that this approach can be applied to another related calculus, D$_{<:}$,  to get D$_{<:}^R$, 
a type system that models core concepts of Scala. D$_{<:}^R$ does not sacrifice certain instances of transitivity and expressiveness that other 
similar designs in the past have.

In future work, we hope to show that this approach can be further applied to the much more complex DOT calculus, by incorporating intersection types and
recursive types.

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.

%%
%% If your work has an appendix, this is the place to put it.
%\appendix
%
%\section{\Fsub}
%\label{app:fsub}
%
%\subsection{Typing}
%
%
%
%\subsection{Operational Semantics}
%
%\subsection{Kernel F$_{<:}$}


%\section{Proof}
%
%\subsection{Subtype Decidability}
%
%\subsection{Transitivity}
%
%\subsection{Type Safety}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
 \bibliographystyle{splncs04}
 \bibliography{bibl}
%
%\begin{thebibliography}{8}
%\end{thebibliography}
\end{document}
